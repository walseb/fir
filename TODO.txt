
Compound types:
  - Arrays (containing any basic type)
  - Records/structs (containing any other types)
  - (Syntactic sugar for) complex numbers & quaternions
  - (Syntactic sugar for) tuples

Operations:
  - comparison (using Ordering, not just < <= > >=)
  - rounding operations
  - bitwise operations on numeric types
  - way to lift operations to vectors (like 'fmap')
  - glsl utility operations (clamp, mix, step, smoothstep, ...)

Control flow:
  - switch
  - loops


need to think about records/structs and in particular memory layout & alignment concerns
structs should use type-level symbols to access individual components
arrays should use runtime ints



fix vector indexing to start from 0 and not 1

figure out how to use fmap for internal vectors/matrices/structs/etc
also need zipWith, e.g. shift operators (zipWith shiftRight intvec datavec)

for some matrix operations (e.g. matrix addition), there are no built-in functions...
instead need to manually "zipWith" using OpCompositeExtra, OpCompositeConstruct



apply RowMajor decoration to matrix type declarations



program optimisation: when possible, bundle together the vector indexing "At" things into a OpVectorShuffle



address string issues:
  - figure out which ByteString to use for SPIR-V internal strings (if any)
  - figure out if the ByteString used in Binary.Put is correct
  - ensure correctness of the binary instance for strings (needed e.g. to import GLSL and to name entry points)



entry point definition:
  add entry points to the indexing, so that entry points have names
  this allows e.g. multiple Vertex entry points (with different names)


figure out how to overload function composition for internal functions


deal with entry point execution modes

make CGMonad polymorphic, so that we can output binary directly, or a human-readable format (or AST)

keep track of extended instruction sets being used